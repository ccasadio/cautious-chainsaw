/*
 * This file was autogenerated
 * DO NOT EDIT
 * (C) 2020 Renesas Electronics Europe Ltd.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * AUTOGENERATED DO NOT EDIT
 *
 * You can override the default mux pullup/down and drive by defining the
 * following macros in the board file before including this.
 */

#ifndef __RZN1_BOARD_PINMUX_H__
#define __RZN1_BOARD_PINMUX_H__

#ifndef RZN1_MUX_DEFAULT
#define RZN1_MUX_DEFAULT RZN1_MUX
#endif

#include "renesas/pinctrl-rzn1.h"

#ifndef RZN1_MUX_CAT
#define RZN1_MUX_CAT RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_ETH3
#define RZN1_MUX_ETH3 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_ETH4
#define RZN1_MUX_ETH4 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_GPIO0
#define RZN1_MUX_GPIO0 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_GPIO1
#define RZN1_MUX_GPIO1 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_GPIO2
#define RZN1_MUX_GPIO2 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_I2C0
#define RZN1_MUX_I2C0 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_I2C1
#define RZN1_MUX_I2C1 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_MDIO1
#define RZN1_MUX_MDIO1 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_MSEBIM
#define RZN1_MUX_MSEBIM RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_QSPI0
#define RZN1_MUX_QSPI0 RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_REFCLK
#define RZN1_MUX_REFCLK RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_UART0
#define RZN1_MUX_UART0 RZN1_MUX_PUP_4MA
#endif
#ifndef RZN1_MUX_UART1
#define RZN1_MUX_UART1 RZN1_MUX_DEFAULT
#endif

#define RZN1_MUX_PERIPH_BIT	24

/*
 * These numbers are arbitrary and don't correspond to anything on the hardware.
 * They *will* change if the pinmux is regenerated by the PinMux App.
 */
enum {
	RZN1_P_CAT = 0, RZN1_P_ETH3, RZN1_P_ETH4, RZN1_P_GPIO0, RZN1_P_GPIO1, RZN1_P_GPIO2,
	RZN1_P_I2C0, RZN1_P_I2C1, RZN1_P_MDIO1, RZN1_P_MSEBIM, RZN1_P_QSPI0, RZN1_P_REFCLK,
	RZN1_P_UART0, RZN1_P_UART1,
};

/*
 * A peripheral number is also encoded in these constants to
 * help parsing in case your code wishes to do pinmux selectively
 */
#define _RZP(_P, _M) ((_M) | (RZN1_##_P << RZN1_MUX_PERIPH_BIT))

static const uint32_t rzn1_pinmux_map[] = {
	_RZP(P_CAT, RZN1_MUX_CAT(80, ETHERCAT)),		/* CAT_MII_LINK[0] */
	_RZP(P_CAT, RZN1_MUX_CAT(81, ETHERCAT)),		/* CAT_MII_LINK[1] */
	_RZP(P_CAT, RZN1_MUX_CAT(83, ETHERCAT)),		/* CAT_SYNC[0] */
	_RZP(P_CAT, RZN1_MUX_CAT(84, ETHERCAT)),		/* CAT_SYNC[1] */
	_RZP(P_CAT, RZN1_MUX_CAT(85, ETHERCAT)),		/* CAT_LATCH[0] */
	_RZP(P_CAT, RZN1_MUX_CAT(86, ETHERCAT)),		/* CAT_LATCH[1] */
	_RZP(P_CAT, RZN1_MUX_CAT(87, ETHERCAT)),		/* CAT_LINKACT[0] */
	_RZP(P_CAT, RZN1_MUX_CAT(88, ETHERCAT)),		/* CAT_LINKACT[1] */
	_RZP(P_CAT, RZN1_MUX_CAT(90, ETHERCAT)),		/* CAT_LEDRUN */
	_RZP(P_CAT, RZN1_MUX_CAT(91, ETHERCAT)),		/* CAT_LEDERR */
	_RZP(P_CAT, RZN1_MUX_CAT(94, ETHERCAT)),		/* CAT_RESETOUT_N */
	_RZP(P_CAT, RZN1_MUX_CAT(144, ETHERCAT)),		/* CAT_I2CCLK */
	_RZP(P_CAT, RZN1_MUX_CAT(145, ETHERCAT)),		/* CAT_I2CDATA */
	_RZP(P_ETH3, RZN1_MUX_ETH3(36, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXCLK */
	_RZP(P_ETH3, RZN1_MUX_ETH3(37, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[0] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(38, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[1] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(39, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[2] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(40, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[3] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(41, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXEN */
	_RZP(P_ETH3, RZN1_MUX_ETH3(42, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXCLK */
	_RZP(P_ETH3, RZN1_MUX_ETH3(43, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[0] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(44, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[1] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(45, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[2] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(46, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[3] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(47, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXDV */
	_RZP(P_ETH3, RZN1_MUX_ETH3(67, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXER */
	_RZP(P_ETH3, RZN1_MUX_ETH3(68, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_CRS */
	_RZP(P_ETH3, RZN1_MUX_ETH3(69, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_COL */
	_RZP(P_ETH4, RZN1_MUX_ETH4(48, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXCLK */
	_RZP(P_ETH4, RZN1_MUX_ETH4(49, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[0] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(50, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[1] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(51, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[2] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(52, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[3] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(53, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXEN */
	_RZP(P_ETH4, RZN1_MUX_ETH4(54, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXCLK */
	_RZP(P_ETH4, RZN1_MUX_ETH4(55, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[0] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(56, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[1] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(57, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[2] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(58, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[3] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(59, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXDV */
	_RZP(P_ETH4, RZN1_MUX_ETH4(71, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXER */
	_RZP(P_ETH4, RZN1_MUX_ETH4(72, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_CRS */
	_RZP(P_ETH4, RZN1_MUX_ETH4(73, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_COL */
	_RZP(P_GPIO0, RZN1_MUX_6MA(3, GPIO)),			/* I2C_Mux_Sel (GPIO0A[1]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(5, GPIO)),			/* NOR_BOOT_RST (GPIO0B[2]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(6, GPIO)),			/* DATA_BOOT_RST (GPIO0B[3]) */
	_RZP(P_GPIO0, RZN1_MUX_PUP_6MA(9, GPIO)),		/* eMMC_RSTn (GPIO0A[3]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(10, GPIO)),			/* PHY_SW_RST (GPIO0A[4]) */
	_RZP(P_GPIO0, RZN1_MUX_PUP(12, GPIO)),			/* FPGA_nIRQ (GPIO0A[5]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(14, GPIO)),			/* SPARE_0 (GPIO0B[8]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(15, GPIO)),			/* SPARE_1 (GPIO0A[6]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(16, GPIO)),			/* SPARE_2 (GPIO0A[7]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(17, GPIO)),			/* SPARE_3 (GPIO0B[9]) */
	_RZP(P_GPIO0, RZN1_MUX_PUP(21, GPIO)),			/* FPGA_PFI_nIRQ (GPIO0A[8]) */
	_RZP(P_GPIO0, RZN1_MUX_PUP(22, GPIO)),			/* CPU_soft_RST_nIRQ (GPIO0A[9]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(62, GPIO)),			/* kGPIO_LED_1 (GPIO0A[25]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(63, GPIO)),			/* kGPIO_LED_2 (GPIO0A[26]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(64, GPIO)),			/* kGPIO_LED_3 (GPIO0A[27]) */
	_RZP(P_GPIO0, RZN1_MUX_6MA(65, GPIO)),			/* kGPIO_LED_4 (GPIO0A[28]) */
	_RZP(P_GPIO1, RZN1_MUX_PDOWN_6MA(154, GPIO)),		/* FPGA_nConfig (GPIO1B[30]) */
	_RZP(P_GPIO1, RZN1_MUX_PUP(155, GPIO)),			/* FPGA_nStatus (GPIO1B[31]) */
	_RZP(P_GPIO2, RZN1_MUX_PUP(147, GPIO)),			/* MII4_INTRP (GPIO2A[25]) */
	_RZP(P_GPIO2, RZN1_MUX_PUP(148, GPIO)),			/* MII5_INTRP (GPIO2A[26]) */
	_RZP(P_GPIO2, RZN1_MUX_6MA(156, GPIO)),			/* FPGA_DCLK (GPIO2A[28]) */
	_RZP(P_GPIO2, RZN1_MUX_6MA(157, GPIO)),			/* FPGA_DATA0 (GPIO2A[29]) */
	_RZP(P_GPIO2, RZN1_MUX_PUP(158, GPIO)),			/* FPGA_CONF_DONE (GPIO2A[30]) */
	_RZP(P_GPIO2, RZN1_MUX_PUP_6MA(159, GPIO)),		/* FPGA_soft_Reset (GPIO2A[31]) */
	_RZP(P_I2C0, RZN1_MUX_I2C0(0, I2C)),			/* I2C0_SDA */
	_RZP(P_I2C0, RZN1_MUX_I2C0(7, I2C)),			/* I2C0_SCL */
	_RZP(P_I2C1, RZN1_MUX_I2C1(1, I2C)),			/* I2C1_SCL */
	_RZP(P_I2C1, RZN1_MUX_I2C1(2, I2C)),			/* I2C1_SDA */
	_RZP(P_MDIO1, RZN1_MUX_MDIO1(152, ETH_MDIO)),		/* MDIO1_MDC */
	_RZP(P_MDIO1, RZN1_MUX_MDIO1(153, ETH_MDIO)),		/* MDIO1_MDIO */
	/*
	 * 170 and 171 are not hardware PL_GPIOs, they are used to
	 * set the MDIO mux mode in a similar fashion as all the other
	 * pinmux functions. See the renesas/rzn1_pinmux.c file.
	 */
	_RZP(P_MDIO1, RZN1_MUX_MDIO1(171, MDIO_MUX_ECAT)),	/* MDIO1_MUX_ECAT */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(105, MSEBIM)),		/* MSEBIM_ACD[0] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(106, MSEBIM)),		/* MSEBIM_ACD[1] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(107, MSEBIM)),		/* MSEBIM_ACD[2] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(108, MSEBIM)),		/* MSEBIM_ACD[3] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(109, MSEBIM)),		/* MSEBIM_ALE */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(110, MSEBIM)),		/* MSEBIM_CLK */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(111, MSEBIM)),		/* MSEBIM_CLE */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(112, MSEBIM)),		/* MSEBIM_DLE */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(113, MSEBIM)),		/* MSEBIM_ACD[4] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(114, MSEBIM)),		/* MSEBIM_ACD[5] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(115, MSEBIM)),		/* MSEBIM_ACD[6] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(116, MSEBIM)),		/* MSEBIM_ACD[7] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(117, MSEBIM)),		/* MSEBIM_WAIT_N[0] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(118, MSEBIM)),		/* MSEBIM_WAIT_N[1] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(119, MSEBIM_E)),		/* MSEBIM_DMA_RD_N[0] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(120, MSEBIM_E)),		/* MSEBIM_DMA_RD_N[1] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(121, MSEBIM_E)),		/* MSEBIM_DMA_WR_N[0] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(122, MSEBIM_E)),		/* MSEBIM_DMA_WR_N[1] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(123, MSEBIM_E)),		/* MSEBIM_RD_N */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(124, MSEBIM_E)),		/* MSEBIM_WR_N */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(133, MSEBIM)),		/* MSEBIM_ALE[1] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(136, MSEBIM)),		/* MSEBIM_ACD[8] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(137, MSEBIM)),		/* MSEBIM_ACD[9] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(138, MSEBIM)),		/* MSEBIM_ACD[10] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(139, MSEBIM)),		/* MSEBIM_ACD[11] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(140, MSEBIM)),		/* MSEBIM_ACD[12] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(141, MSEBIM)),		/* MSEBIM_ACD[13] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(142, MSEBIM)),		/* MSEBIM_ACD[14] */
	_RZP(P_MSEBIM, RZN1_MUX_MSEBIM(143, MSEBIM)),		/* MSEBIM_ACD[15] */
	_RZP(P_QSPI0, RZN1_MUX_PUP_6MA(74, QSPI)),		/* QSPI0_CS_N[0] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(75, QSPI)),		/* QSPI0_IO[3] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(76, QSPI)),		/* QSPI0_IO[2] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(77, QSPI)),		/* QSPI0_IO[1] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(78, QSPI)),		/* QSPI0_IO[0] */
	_RZP(P_QSPI0, RZN1_MUX_12MA(79, QSPI)),			/* QSPI0_CLK */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(149, QSPI)),		/* QSPI0_CS_N[2] */
	_RZP(P_REFCLK, RZN1_MUX_REFCLK(60, CLK_ETH_NAND)),	/* REFCLK_MII[0] */
	_RZP(P_REFCLK, RZN1_MUX_REFCLK(61, CLK_ETH_NAND)),	/* REFCLK_MII[1] */
	_RZP(P_UART0, RZN1_MUX_UART0(103, UART0_I)),		/* UART0_TXD */
	_RZP(P_UART0, RZN1_MUX_UART0(104, UART0_I)),		/* UART0_RXD */
	_RZP(P_UART1, RZN1_MUX_UART1(166, UART1_I)),		/* UART1_TXD */
	_RZP(P_UART1, RZN1_MUX_UART1(167, UART1_I)),		/* UART1_RXD */
	0L, /* terminator */
};
/*
 * Sample function for setting the pinmux. Pass -1 for setting /all/
 * the pins, pass any of the RZN1_P_xxx for setting just that one set
 * returns the number of pins that have been set.
 * There is also a variant where you can pass multiple peripherals as
 * a bitmask.
 */
#ifdef USE_DEFAULT_PINMUX
/* Functions are marked 'unused' to prevent warnings on modern GCC */
#if defined(__GNUC__)
#define __unused __attribute__((unused))
#elif !defined(__unused)
#define __unused
#endif
static int rzn1_board_pinmux(int periph /* = -1 */) __unused;
static int rzn1_board_pinmux(int periph /* = -1 */) {
 int i, cnt = 0;
 for (i = 0; rzn1_pinmux_map[i]; i++)
  if (periph == -1 ||
      (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT) == (uint32_t)periph) {
       rzn1_pinmux_set(rzn1_pinmux_map[i]);
       cnt++;
 }
 return cnt;
}
static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) __unused;
static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) {
 int i, cnt = 0;
 for (i = 0; rzn1_pinmux_map[i]; i++)
  if (periph_mask & (1 << (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT))) {
   rzn1_pinmux_set(rzn1_pinmux_map[i]);
   cnt++;
  }
 return cnt;
}
#endif

/*
 * This is the compressed Renesas PinMux App data structure. It allows you to
 * load this file into the App, make changes and generate/save the file again.
 * It is only used by the PinMux App
 */
#ifdef JSON_PRESET
N4IgdghgtgpiBcIDCAFAqgfQKIFkdIwA4AjASwBcMBFAZRQEkMkAZJAaQwEYAmKAQSZ8AKhgBKWGliEB5NCIByGNH1EicaABoYwA
ewzpmzJShAAaEAAcIAYwDWEAOZxEMACwAGd2cswATqQsACz8IABsAZwQAbWRhbykACVd4oQSAVm8AcQZpTiyc7nz6aQBmb3puJDz
zCqRC8xwAEWL6kBxJACF6HG9aBmqQcQAxFjZvZVUBiaFCgF1zBwtSPUhYSPhQPMRajBwAVwAPDBoYUO9CxGndw+PT7zKXPAJRGiE
wb2TEFASATWOAdTEr28GUQQxQmQEYHooio3gAbAgQHQVFguN4AOxIlHiDCtQhI8GQ/RDRjQ2HeACcSNQmHCOgAZpQXiJyXDzNxQS
BbNlihhmFhGuiOYjEDycvzBXjzlixbzpJKhWUOQS5RKBULkuYSp8QPJpKIMB1pNIRCz7lzGsIBMbTUChB8vIgcWivOZXFtkShURh
lSAeKKQESoUgdGAGaQHN4eLKgxCoTRyBByHtIuZOGkHm16PRXBh6PIhKITOm0rqcDm0vnC8Xo2lA8GMI1RnXY42rUI+G7/WlVXHi
UhpPIhk2h1g69SwfGMPSmWIYOEYOQQABfBZLHTrKKuQg8QimHc8SkH3cldymbiuVzcbgY0ycDHwymuR8Xq834+X69nk+cEppe9dw
xdxKTvL9uB1e94W4dxXEpbg32/fdwJKT93w8RDL04KCYLSdxsM4aD3DwhCSjIwjTDIkoH0o8j9yozhjyomDaJKbhsOY0iyIg1jL1
4gDmPhXi72Y+juKYqjzyo6jWLY2SSlk1xZIEqihOkkSqLEsiJLSSk1P/UDMMIITwMIMD30IZCLIknUNJ1LS4NYtIOLItIuP/BTOE
IdxNNo4yNOMsTjIkszzzg7hoIU/94XhJTovhAT63hESkvopKmPrYDKMyjjMtIzK4syxLkvoj1XCisq4rKgSyrUsqRLK0rOEcnUM3
PQjH0pHyoM62DKPCjjwtI8KKvgqr4Jq+C6vghr4NK+CmLgn8dUpGSVrk9bRsgkoMQgpjdownasMog7SIOqKDvGlq4Lc/rKUzO6y0
eyb60e2be0ejLdrS3bj0ImDoLvf73GgsTnw4hK+pKSGBMpZrUKU4H4X/RCSm81HdxwkG0cAh9LxErqMXownjzLLyMVmFcgA=
#endif

#endif /* __RZN1_BOARD_PINMUX_H__ */
